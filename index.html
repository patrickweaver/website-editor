<!DOCTYPE html>
<html lang="en" id="html-element">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="description"
      content="A website that edits itself"
      id="page-description"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title id="page-title">Website</title>

    <!-- Favicon - SVG from Emoji: https://emojicon.dev/ -->
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ““</text></svg>"
    />

    <!-- Social -->
    <meta property="og:title" content="Website" id="meta-title" />
    <meta
      property="og:description"
      content="A website that edits itself"
      id="meta-description"
    />
    <meta property="og:image" content="" id="meta-image" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary" id="twitter-card" />
    <meta name="twitter:title" content="Website" id="twitter-title" />
    <meta
      name="twitter:description"
      content="A website that edits itself"
      id="twitter-description"
    />
    <meta name="twitter:image" content="" id="twitter-image" />
    <meta name="twitter:image:alt" content="" id="twitter-image-alt" />

    <!-- CSS -->
    <style>
      :root {
        --button-del-bg: #ffbfbf;
        --button-del-border: #ff0000;
        --button-del-hover-bg: #ffafaf;
        --button-del-hover-border: #ff2f2f;
        --local-controls-bg: #dfdfe8;
        --local-controls-bg-2: #f8f8ff;
        --local-controls-bg-3: #f4f4f4;
        --local-controls-border-3: #2f2f2f;
        --modal-shadow-bg: #4f4f4fdf;
        --new-element-highlight: #00ffff;
        --edit-element-highlight: #ffff00;
      }

      body {
        font-family: "Arial", sans-serif;
        margin: 2rem;
      }

      input,
      textarea {
        font-size: 1rem;
        line-height: 1.2rem;
        padding: 0.5rem;
        margin: 0.25rem 0;
      }

      textarea {
        width: Calc(100% - 1rem);
        min-height: 6rem;
        font-family: "Arial", sans-serif;
      }

      img {
        display: block;
        margin: 1rem 0;
      }

      #local-controls figure {
        margin: 0 0 1rem;
      }

      #local-controls figure figcaption,
      #local-controls figure img {
        display: inline;
        margin: 0;
      }

      #local-controls figure img {
        width: 16px;
        position: relative;
        top: 3px;
      }

      .color-picker {
        height: 2rem;
        padding: 2px;
      }

      .edit-container {
        border-radius: 3px;
      }

      .edit-container {
        border: 2px solid var(--edit-element-highlight);
        margin: 1rem 0;
        padding: 0.5rem;
        background-color: var(--local-controls-bg);
      }

      .edit-container select {
        display: block;
      }

      .clone-container {
        border: 1px solid var(--local-controls-border-3);
        background-color: var(--local-controls-bg-3);
        padding: 1rem;
        margin: 0.5rem 0 1rem;
      }

      .clone {
        opacity: 50%;
        margin: 0;
      }

      label.edit,
      input.edit {
        width: Calc(100% - 1rem);
        margin-bottom: 0.5rem;
      }

      #local-controls {
        background-color: var(--local-controls-bg);
        margin: 4rem 0 1rem;
        padding: 0.5rem 1rem;
      }

      #local-controls button,
      .edit-buttons button {
        margin: 0 0.25rem;
        display: inline-block;
        font-size: 1.125rem;
      }

      .controls-section {
        width: 100%;
        margin: 0.5em 0 2rem;
      }

      .controls-section label,
      .controls-section input,
      .controls-section textarea,
      .controls-section button {
        display: block;
      }

      .controls-section input,
      .controls-section textarea,
      .controls-section button {
        margin: 0.5rem 0 1rem;
      }

      .controls-section .below-label {
        margin: -0.5rem 0 1rem;
      }

      #update-favicon {
        margin-bottom: 0.25rem;
      }

      .edit-buttons {
        background-color: var(--local-controls-bg);
        margin: 0.5rem 0;
        display: inline-block;
      }

      .edit-buttons button.delete-button {
        border: 2px outset var(--button-del-border);
        background-color: var(--button-del-bg);
      }

      .edit-buttons button.delete-button:hover {
        border: 2px outset var(--button-del-hover-border);
        background-color: var(--button-del-hover-bg);
      }

      .controls-section label {
        margin: 0.25rem 0;
      }

      #new-content-modal-wrapper {
        position: fixed;
        width: 100vw;
        height: 100vh;
        top: 0;
        left: 0;
        background-color: var(--modal-shadow-bg);
      }

      #new-content-modal {
        margin: 5rem 10% 0;
        background-color: var(--local-controls-bg-2);
        padding: 1rem 2rem;
        width: Calc(80% - 2rem - 2rem); /* 2rem is body margin */
      }

      #new-content-modal li {
        margin: 0.5rem;
      }
    </style>
  </head>
  <body style="background-color: #dda0dd">
    <h1>Website</h1>

    <h2>About Me</h2>

    <p>I can update this website locally in my browser.</p>

    <img
      src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' width='100' height='100'><text y='0.9em' font-size='90'>ðŸ““</text></svg>"
    />

    <hr id="end-of-document" style="display: none" />

    <!-- JS -->
    <script type="text/javascript" id="js">
      const DEV_MODE = false;
      var editingStateDirty = false;

      /* Check for local file */
      const protocol = window.location.protocol;
      if (protocol === "file:") {
        localEditingMode();
      }

      /* Editng JavaScript only runs locally */
      function localEditingMode() {
        // Constants
        const PAGE_TITLE_INPUT_ID = "edit-page-title";
        const PAGE_DESC_INPUT_ID = "edit-page-description";
        const PAGE_LANG_INPUT_ID = "edit-page-language";
        const ADD_ITEM_ID = "add-item";
        const ADD_ITEM_ID_PREFIX = "add-item-";
        const ADD_ITEM_HEADING_ID = `${ADD_ITEM_ID_PREFIX}heading`;
        const ADD_ITEM_IMAGE_ID = `${ADD_ITEM_ID_PREFIX}image`;
        const ADD_ITEM_PARAGRAPH_ID = `${ADD_ITEM_ID_PREFIX}paragraph`;
        const ADD_ITEM_CANCEL_ID = `${ADD_ITEM_ID_PREFIX}cancel`;
        const CURRENT_FAVICON_PREVIEW_ID = "current-favicon-preview";
        const UPDATE_FAVICON_ID = "update-favicon";
        const CANCEL_FAVICON_UPDATE_ID = "cancel-favicon-update";
        const CONFIRM_FAVICON_UPDATE_ID = "confirm-favicon-update";
        const CURRENT_SOCIAL_IMAGE_ID = "meta-image";
        const CURRENT_TWITTER_IMAGE_ID = "twitter-image";
        const CURRENT_SOCIAL_IMAGE_PREVIEW_ID = "current-social-image-preview";
        const UPDATE_SOCIAL_IMAGE_ID = "update-social-image";
        const CANCEL_SOCIAL_IMAGE_UPDATE_ID = "cancel-social-image-update";
        const CONFIRM_SOCIAL_IMAGE_UPDATE_ID = "confirm-social-image-update";
        const UPDATE_BACKGROUND_COLOR_ID = "update-background-color";
        const COLOR_PICKER_CLASS = "color-picker";
        const SAVE_CHANGES_ID = "save-changes";
        const CLONE_LABEL = "Original Element";
        const CLONE_CLASS = "clone";
        const CLONE_CONTAINER_CLASS = "clone-container";
        const EDIT_CLASS = "edit";
        const EDIT_CONTAINER_CLASS = "edit-container";
        const EDIT_BUTTONS_CLASS = "edit-buttons";
        const TEXT_EDITOR_ID_READABLE_STRING = "text-editor";
        const IMAGE_PICKER_ID_READABLE_STRING = "image-picker";
        const END_OF_DOC_ID = "end-of-document";
        const LOCAL_CONTROLS_ID = "local-controls";
        const NEW_CONTENT_MODAL_WRAPPER = "new-content-modal-wrapper";
        const HEADING_ELEMENTS = ["h1", "h2", "h3", "h4", "h5", "h6"];
        const PARAGRAPH_ELEMENT = "p";
        const IMG_ELEMENT = "img";

        const EDITOR_TYPES = {
          TEXT: "text",
          HEADING: "heading",
          HEADING_LEVEL: "heading-level",
          PARAGRAPH: "paragraph",
          IMAGE: "image",
          IMAGE_ALT_TEXT: "image-alt",
        };

        const STRINGS = {
          BUTTON_CANCEL: "Cancel",
          BUTTON_DELETE: "Delete",
          BUTTON_LINK: "Make Link From Selection",
          BUTTON_SAVE: "Save",
          BUTTON_UPDATE: "Update",
          CONFIRM_DELETE: "Are you sure you want to delete this element?",
          ERROR_IMAGE_ONLY: "Error: Please choose an image file",
          ERROR_NO_IMAGE: "Error: No image found",
          ERROR_NO_SELECTION: "Error: Nothing selected",
          EDITOR_LABELS: {
            [EDITOR_TYPES.PARAGRAPH]: "Edit paragraph text",
            [EDITOR_TYPES.HEADING]: "Edit heading text",
            [EDITOR_TYPES.HEADING_LEVEL]: "Edit heading level",
            [EDITOR_TYPES.IMAGE]: "Select an image",
            [EDITOR_TYPES.IMAGE_ALT_TEXT]: "Image alt text",
          },
          PLACEHOLDER_TEXT: "Your text here",
          PROMPT_LINK_URL: "URL:",
        };

        const currentFaviconURL =
          document.querySelector("link[rel~='icon']").href;
        const currentBackgroundColor = getBodyBackgroundColor();
        const { href: currentSocialImageURL, alt: currentSocialImageAlt } =
          document.getElementById(CURRENT_SOCIAL_IMAGE_ID);

        const NEW_CONTENT_MODAL_HTML = `
          <div id="new-content-modal">
            <h2>Add New Content</h2>
            <ul>
              <li><button id="${ADD_ITEM_HEADING_ID}">Heading</button></li>
              <li><button id="${ADD_ITEM_PARAGRAPH_ID}">Paragraph</button></li>
              <li><button id="${ADD_ITEM_IMAGE_ID}">Image</button></li>
            </ul>
            <button id="${ADD_ITEM_CANCEL_ID}">Cancel</button>
          </div>
        `;

        const LOCAL_CONTROLS_HTML = `
          <h2>Local Controls</h2>
          <p>This section of the page will only display when viewing the local version of your website by opening the <code>index.html</code> file on a computer.
          <hr/>

          <div class="controls-section">
            <h3>Add Content<h3>
            <button id="${ADD_ITEM_ID}">Add Item</button>
          </div>

          <h3>Metadata</h3>

          <div class="controls-section">
            <h4>General</h4>
            <label for="${PAGE_TITLE_INPUT_ID}">Page Title: </label>
            <input type="text" id="${PAGE_TITLE_INPUT_ID}" />
            <label for="${PAGE_DESC_INPUT_ID}">Page Description</label>
            <textarea id="${PAGE_DESC_INPUT_ID}" style="min-height: 2rem"></textarea>
            <label for="${PAGE_LANG_INPUT_ID}">Page Language</label>
            <input type="text" id="${PAGE_LANG_INPUT_ID}" value="${
          document.documentElement.lang
        }" />
            <label for="edit-page-langauge" class="below-label">See list of valid language tags <a href="https://en.wikipedia.org/wiki/IETF_language_tag#List_of_subtags" target="_blank">here</a>.
          </div>

          <div class="controls-section">
            <h4>Background Color</h4>
            <input type="color" value="${currentBackgroundColor}" class="${COLOR_PICKER_CLASS}" id="${UPDATE_BACKGROUND_COLOR_ID}" />
          </div>

          <div class="controls-section">
            <h4>Favicon</h4>
            <figure id="favicon-preview">
              <figcaption>Current Favicon:</figcaption>
              <img id="${CURRENT_FAVICON_PREVIEW_ID}" src="${currentFaviconURL}"
              alt="The current favicon">
            </figure>
            <label for="${UPDATE_FAVICON_ID}">Update Favicon</label>
            <input id="${UPDATE_FAVICON_ID}" type="file" />
            <div class="${EDIT_BUTTONS_CLASS}">
              <button id="${CANCEL_FAVICON_UPDATE_ID}" disabled>${
          STRINGS.BUTTON_CANCEL
        }</button>
              <button id="${CONFIRM_FAVICON_UPDATE_ID}" disabled>${
          STRINGS.BUTTON_UPDATE
        }</button>
            </div>
          </div>

          <div class="controls-section">
            <h4>Social Image</h4>
            <figure id="social-image-preview">
              <figcaption>Current Social Image:</figcaption>
              <img
                id="${CURRENT_SOCIAL_IMAGE_PREVIEW_ID}"
                src="${currentSocialImageURL ?? ""}"
                alt="${
                  currentSocialImageAlt ?? currentSocialImageURL
                    ? ""
                    : "&nbsp;Social Image is not set."
                }"
              >
            </figure>
            <label for="${UPDATE_SOCIAL_IMAGE_ID}">Update Social Image</label>
            <input id="${UPDATE_SOCIAL_IMAGE_ID}" type="text" />
            <div class="${EDIT_BUTTONS_CLASS}">
              <button id="${CANCEL_SOCIAL_IMAGE_UPDATE_ID}" disabled>${
          STRINGS.BUTTON_CANCEL
        }</button>
              <button id="${CONFIRM_SOCIAL_IMAGE_UPDATE_ID}" disabled>${
          STRINGS.BUTTON_UPDATE
        }</button>
            </div>
          </div>

          <div class="controls-section">
            <h3>Save Changes</h3>
            <button id="${SAVE_CHANGES_ID}">Save All Changes to Local File</button>
          </div>
        `;

        function makeElementEventListener(editorType) {
          return function (event, isExistingElement = true) {
            const element = event.currentTarget;
            let elementClone;
            if (isExistingElement) {
              elementClone = element.cloneNode(true);
              elementClone.classList.add(CLONE_CLASS);
            }
            const originalDisplay = element.style.display;
            element.style.display = "none";
            const {
              tagName: _tagName,
              innerHTML: originalContent,
              alt: altTextContent,
            } = element;
            const tagName = _tagName.toLowerCase();

            const deleteButton = {
              label: STRINGS.BUTTON_DELETE,
              initiallyDisabled: false,
              updateElement: ({ editorElement, originalElement }) => {
                const result = window.confirm(STRINGS.CONFIRM_DELETE);
                if (!result) return;
                editorElement.remove();
                originalElement.remove();
                return true;
              },
            };

            const cancelButton = {
              label: STRINGS.BUTTON_CANCEL,
              initiallyDisabled: false,
              updateElement: ({}) => true,
            };

            const linkButton = {
              label: STRINGS.BUTTON_LINK,
              initiallyDisabled: false,
              updateElement: ({ editorId }) => {
                const selectableInput = document.getElementById(editorId);
                selectableInput.value = addLinkAroundSelection(selectableInput);
              },
            };

            const updateButtonLabel = isExistingElement
              ? STRINGS.BUTTON_UPDATE
              : STRINGS.BUTTON_SAVE;

            const updateTextButton = {
              label: updateButtonLabel,
              initiallyDisabled: false,
              updateElement: ({
                editorElement,
                tagNameSelect,
                originalElement,
              }) => {
                let updatedElement = originalElement;
                const newContent = editorElement.value;
                if (!newContent) return false;
                const tagChanged =
                  tagNameSelect &&
                  tagName !== tagNameSelect.value.toLowerCase();
                if (tagChanged) {
                  updatedElement = createElement(tagNameSelect.value);
                  originalElement.insertAdjacentElement(
                    "beforebegin",
                    updatedElement
                  );
                  originalElement.remove();
                  activateHeading(updatedElement);
                }
                const contentChanged = newContent !== originalContent;
                updatedElement.innerHTML = newContent;
                editingStateDirty =
                  editingStateDirty || tagChanged || contentChanged;
                return true;
              },
            };

            const upateImageButton = {
              label: updateButtonLabel,
              initiallyDisabled: true,
              updateElement: ({
                editorElement: imagePicker,
                altTextEditor,
                originalElement,
              }) => {
                const updatedImage = addImage(
                  imagePicker.id,
                  altTextEditor?.value,
                  originalElement
                );
                const _editingStateDirty =
                  updatedImage?.src !== originalElement?.src ||
                  updatedImage?.alt !== originalElement?.alt;
                if (!updatedImage) return false;
                originalElement.remove();
                editingStateDirty = editingStateDirty || _editingStateDirty;
                return true;
              },
            };

            const defaultButtons = [deleteButton];
            if (isExistingElement) {
              defaultButtons.unshift(cancelButton);
            }

            let types = {
              text: {
                idReadableString: TEXT_EDITOR_ID_READABLE_STRING,
                controls: [...defaultButtons, linkButton, updateTextButton],
                createEditor: createTextEditor,
              },
              [EDITOR_TYPES.IMAGE]: {
                idReadableString: IMAGE_PICKER_ID_READABLE_STRING,
                controls: [...defaultButtons, upateImageButton],
                createEditor: createImageEditor,
              },
            };
            types[EDITOR_TYPES.HEADING] = types.text;
            types[EDITOR_TYPES.PARAGRAPH] = types.text;
            const type = types[editorType];

            const editorId = uniqueId(type.idReadableString);

            const editElements = type.createEditor({
              id: editorId,
              type: editorType,
              confirmButtonLabel: updateButtonLabel,
              content: originalContent,
              tagName,
              altTextContent,
            });
            const {
              editor,
              editorLabel,
              tagPicker,
              tagPickerLabel,
              altEditor,
              altEditorLabel,
            } = editElements;

            let buttonsContainerElement = createElement("div");
            buttonsContainerElement.classList.add(EDIT_BUTTONS_CLASS);

            let editorContainerElement = createElement("div");
            editorContainerElement.classList.add(EDIT_CONTAINER_CLASS);
            editorContainerElement.id = getEditorContainerId(editorId);

            if (isExistingElement) {
              const elementCloneContainer = createElement("div");
              elementCloneContainer.classList.add(CLONE_CONTAINER_CLASS);

              elementCloneContainer.insertAdjacentElement(
                "beforeend",
                elementClone
              );

              editorContainerElement.insertAdjacentElement(
                "beforeend",
                elementCloneContainer
              );

              const elementCloneLabel = createElement("label");
              elementCloneLabel.innerHTML = CLONE_LABEL;
              elementCloneContainer.insertAdjacentElement(
                "beforebegin",
                elementCloneLabel
              );
            }

            type.controls.forEach((i) => {
              let buttonElement = createElement("button");
              buttonElement.classList.add(`${slugify(i.label)}-button`);
              buttonElement.id = getButtonId(i.label, editorId);
              buttonElement.disabled = i.initiallyDisabled;
              buttonElement.innerHTML = i.label;
              buttonsContainerElement.insertAdjacentElement(
                "beforeend",
                buttonElement
              );
              buttonElement.addEventListener("click", function (_event) {
                const success = i.updateElement({
                  editorElement: editor,
                  tagNameSelect: tagPicker,
                  altTextEditor: altEditor,
                  originalElement: element,
                  editorId,
                });
                if (success) {
                  editorContainerElement.remove();
                  element.style.display = originalDisplay;
                }
              });
            });

            element.insertAdjacentElement(
              "beforebegin",
              editorContainerElement
            );
            // Reverse so labels are placed above inputs
            const editElementsArray = [
              tagPickerLabel,
              tagPicker,
              editorLabel,
              editor,
              altEditorLabel,
              altEditor,
              buttonsContainerElement,
            ];
            editElementsArray.forEach((editorElement) => {
              if (!editorElement) return;
              editorContainerElement.insertAdjacentElement(
                "beforeend",
                editorElement
              );
            });

            editor.focus();
            editor.select();
          };
        }

        /* Activate existing elements for editing */
        function makeActivator(type) {
          return function (element) {
            element.addEventListener("click", makeElementEventListener(type));
          };
        }

        // Headings
        function activateHeading(element) {
          makeActivator(EDITOR_TYPES.HEADING)(element);
        }
        document
          .querySelectorAll(HEADING_ELEMENTS.join(", "))
          .forEach(activateHeading);

        // Paragraph
        function activateParagraph(element) {
          makeActivator(EDITOR_TYPES.PARAGRAPH)(element);
        }
        document.querySelectorAll(PARAGRAPH_ELEMENT).forEach(activateParagraph);

        // Image
        function activateImage(element) {
          makeActivator(EDITOR_TYPES.IMAGE)(element);
        }
        document.querySelectorAll("img").forEach(activateImage);

        /* Local Controls */
        let localControls = createElement("div");
        localControls.id = LOCAL_CONTROLS_ID;
        localControls.innerHTML = LOCAL_CONTROLS_HTML;

        function addLocalControls() {
          document
            .getElementById(END_OF_DOC_ID)
            .insertAdjacentElement("afterend", localControls);

          document
            .getElementById(ADD_ITEM_ID)
            .addEventListener("click", showNewContentModal);

          window.addEventListener("beforeunload", function (event) {
            if (!DEV_MODE && editingStateDirty) {
              event.preventDefault();
              event.returnValue = "";
            }
          });
        }

        addLocalControls();

        /* Activate Controls on Existing Elements */
        document
          .getElementById(UPDATE_BACKGROUND_COLOR_ID)
          .addEventListener("change", onUpdateBackgorundColor);
        document
          .getElementById(UPDATE_FAVICON_ID)
          .addEventListener("change", makeOnUpdateFaviconPicker());

        /* Add Content */
        function showNewContentModal() {
          let newContentModal = createElement("div");
          newContentModal.id = NEW_CONTENT_MODAL_WRAPPER;
          newContentModal.innerHTML = NEW_CONTENT_MODAL_HTML;

          document
            .getElementById(LOCAL_CONTROLS_ID)
            .insertAdjacentElement("beforeend", newContentModal);

          function clearAddItemModal() {
            document.getElementById(NEW_CONTENT_MODAL_WRAPPER).remove();
          }

          // Heading, Paragraph, and Image buttons
          const addTextItemButtonIds = [
            ADD_ITEM_HEADING_ID,
            ADD_ITEM_PARAGRAPH_ID,
            ADD_ITEM_IMAGE_ID,
          ];
          addTextItemButtonIds.forEach((buttonId) => {
            document
              .getElementById(buttonId)
              .addEventListener("click", (event) => {
                addItem(
                  event.currentTarget.id.slice(
                    ADD_ITEM_ID_PREFIX.length,
                    event.currentTarget.id.length
                  )
                );
                clearAddItemModal();
              });
          });

          // cancel Button
          document
            .getElementById(ADD_ITEM_CANCEL_ID)
            .addEventListener("click", clearAddItemModal);
        }

        function addImage(filePickerId, altText, originalElement) {
          const update = filePickerId !== ADD_ITEM_IMAGE_ID;
          const filePicker = document.getElementById(filePickerId);
          const file = filePicker.files[0];
          if (file && !isImageFile(file)) {
            // This won't happen because button is disabled
            // unless file is an image
            alert(STRINGS.ERROR_IMAGE_ONLY);
            return null;
          }
          const newElement = createElement("img");
          if (update) {
            // Add image above current image
            filePicker.parentElement.insertAdjacentElement(
              "afterend",
              newElement
            );
          } else {
            // Add image at the end of the document
            addAtEndOfDocument(newElement);
          }
          scrollToNewElement(newElement);

          // Set img src to file contents as Data URL
          if (file) {
            setFileAsDataURL(file, newElement);
          } else if (originalElement.src) {
            newElement.src = originalElement.src;
          } else {
            alert(STRINGS.ERROR_NO_IMAGE);
            return null;
          }

          if (altText) newElement.alt = altText;

          newElement.addEventListener(
            "click",
            makeElementEventListener(EDITOR_TYPES.IMAGE)
          );
          return newElement;
        }

        function addItem(type) {
          let elementType;
          if (type === EDITOR_TYPES.HEADING) {
            elementType = HEADING_ELEMENTS[1];
          } else if (type === EDITOR_TYPES.PARAGRAPH) {
            elementType = PARAGRAPH_ELEMENT;
          } else if (type === EDITOR_TYPES.IMAGE) {
            elementType = IMG_ELEMENT;
          }

          const newElement = createElement(elementType);
          const editCallback = makeElementEventListener(type);
          if (
            type === EDITOR_TYPES.HEADING ||
            type === EDITOR_TYPES.PARAGRAPH
          ) {
            newElement.innerHTML = STRINGS.PLACEHOLDER_TEXT;
          }
          addAtEndOfDocument(newElement);
          scrollToNewElement(newElement);
          const fakeEvent = { currentTarget: newElement };
          editCallback(fakeEvent, false);
        }

        /* Page Metadata */
        function metaDataEditor(
          editElementId,
          mainElementId,
          secondaryElementIdArray,
          mainProperty = "content",
          secondaryProperty = "content"
        ) {
          const editElement = document.getElementById(editElementId);
          const mainElement = document.getElementById(mainElementId);
          editElement.value = mainElement[mainProperty];

          editElement.addEventListener("input", (event) => {
            const newValue = editElement.value;
            mainElement[mainProperty] = newValue;
            secondaryElementIdArray.forEach((element) => {
              document.getElementById(element)[secondaryProperty] = newValue;
            });
          });
        }

        metaDataEditor(
          PAGE_TITLE_INPUT_ID,
          "page-title",
          ["meta-title", "twitter-title"],
          "innerHTML"
        );

        metaDataEditor(PAGE_DESC_INPUT_ID, "page-description", [
          "meta-description",
          "twitter-description",
        ]);

        metaDataEditor(PAGE_LANG_INPUT_ID, "html-element", [], "lang");

        /* Save Changes */
        document
          .getElementById(SAVE_CHANGES_ID)
          .addEventListener("click", async function (_event) {
            localControls.remove();
            const htmlSourceCode = `
            <!DOCTYPE html>
            <html lang="${document.documentElement.lang}"  id="html-element">
              <head>
                ${document.head.innerHTML}
              </head>
              <body style="background-color: ${getBodyBackgroundColor()}">
                ${document.body.innerHTML}
              </body>
            </html>
          `;
            try {
              await saveFile(htmlSourceCode);
            } catch (error) {
              if (error?.message === "The user aborted a request.") {
                // Error is just cancel button
              } else {
                alert(error?.message ?? "Error saving file.");
              }
            }
            addLocalControls();
          });

        // Chromium only
        // https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/write
        async function saveFile(data) {
          // create a new handle
          const newHandle = await window.showSaveFilePicker({
            startIn: "desktop",
            suggestedName: "index.html",
            types: [
              { description: "HTML", accept: { "text/markdown": [".html"] } },
            ],
          });
          // create a FileSystemWritableFileStream to write to
          const writableStream = await newHandle.createWritable();
          // write our file
          await writableStream.write(data);
          // close the file and write the contents to disk.
          await writableStream.close();
        }

        function createTextEditor({
          id,
          type,
          confirmButtonLabel,
          content,
          tagName,
        }) {
          let levelEditorId, editLevelLabel;
          if (type === EDITOR_TYPES.HEADING) {
            levelEditorId = `level-${id}`;
            var editLevelElement = createElement("select");
            HEADING_ELEMENTS.forEach((level) => {
              let headingLevelElement = createElement("option");
              headingLevelElement.innerHTML = level;
              headingLevelElement.value = level;
              if (level.toLowerCase() === tagName) {
                headingLevelElement.selected = "selected";
              }
              editLevelElement.insertAdjacentElement(
                "beforeend",
                headingLevelElement
              );
            });
            editLevelLabel = createEditorLabel(
              levelEditorId,
              EDITOR_TYPES.HEADING_LEVEL
            );
          }

          let editElement = createElement("textarea");
          editElement.id = id;
          editElement.classList.add(EDIT_CLASS);
          editElement.innerHTML = content;
          editElement.addEventListener(
            "input",
            makeEditorChangeListener(id, confirmButtonLabel)
          );

          const editElementLabel = createEditorLabel(id, type);
          return {
            editor: editElement,
            editorLabel: editElementLabel,
            tagPicker: editLevelElement,
            tagPickerLabel: editLevelLabel,
          };
        }

        function createImageEditor({
          id,
          type,
          confirmButtonLabel,
          altTextContent,
        }) {
          const imagePicker = createElement("input");
          imagePicker.type = "file";
          imagePicker.id = id;
          imagePicker.classList.add(EDIT_CLASS);
          imagePicker.addEventListener(
            "change",
            makeEditorChangeListener(id, confirmButtonLabel)
          );
          const imagePickerLabel = createEditorLabel(id, type);
          const altEditor = createElement("input");
          altEditor.type = "text";
          const altEditorId = `alt-text-${id}`;
          altEditor.id = altEditorId;
          altEditor.classList.add(EDIT_CLASS);
          altEditor.value = altTextContent ?? "";
          altEditor.addEventListener(
            "input",
            makeEditorChangeListener(id, confirmButtonLabel)
          );
          const altEditorLabel = createEditorLabel(
            altEditorId,
            EDITOR_TYPES.IMAGE_ALT_TEXT
          );
          return {
            editor: imagePicker,
            editorLabel: imagePickerLabel,
            altEditor,
            altEditorLabel,
          };
        }

        function makeEditorChangeListener(id, confirmButtonLabel) {
          return function (event) {
            const updateButtonId = getButtonId(confirmButtonLabel, id);
            const updateButton = document.getElementById(updateButtonId);
            const { tagName: _tagName, type, files } = event.currentTarget;
            const tagName = _tagName.toLowerCase();
            if (tagName === "textarea" && updateButton) {
              updateButton.disabled = !event.currentTarget.value;
            } else if (tagName === "input" && type === "file") {
              const validFile = isImageFile(files[0]);
              updateButton.disabled = !validFile;
              if (!validFile) {
                alert(STRINGS.ERROR_IMAGE_ONLY);
              }
            } else if (tagName === "input" && type === "text") {
              updateButton.disabled = false;
            }
          };
        }

        function createEditorLabel(editorId, type) {
          let editElementLabel = createElement("label");
          editElementLabel.innerHTML = STRINGS.EDITOR_LABELS[type];
          editElementLabel.htmlFor = editorId;
          editElementLabel.classList.add(EDIT_CLASS);
          return editElementLabel;
        }

        function makeOnUpdateFaviconPicker() {
          return makeUpdateMetaImagePicker({
            cancelButtonId: CANCEL_FAVICON_UPDATE_ID,
            confirmButtonId: CONFIRM_FAVICON_UPDATE_ID,
            querySelector: "link[rel~='icon']",
            insertHandler: insertFavicon,
          });
        }

        function makeUpdateMetaImagePicker({
          cancelButtonId,
          confirmButtonId,
          querySelector,
          insertHandler,
        }) {
          return (changeEvent) => {
            const file = changeEvent.target.files[0];
            const validFile = isImageFile(file);

            const UPDATE_METHODS = {
              REMOVE: "removeEventListener",
              ADD: "addEventListener",
            };

            const updateButtons = [
              {
                id: cancelButtonId,
                onClick: (clickEvent) => {
                  updateHandler(true, UPDATE_METHODS.REMOVE);
                },
              },
              {
                id: confirmButtonId,
                onClick: (clickEvent) => {
                  updateHandler(true, UPDATE_METHODS.REMOVE);
                  confirmHandler(file);
                },
              },
            ];

            function updateHandler(disabled, method) {
              if (disabled) {
                changeEvent.target.value = "";
              }
              updateButtons.forEach((i) => {
                const button = document.getElementById(i.id);
                button.disabled = disabled;
                button[method]("click", i.onClick);
              });
            }

            function confirmHandler(file) {
              insertHandler(file);
              editingStateDirty = true;
            }

            updateHandler(!validFile, UPDATE_METHODS.ADD);

            if (!validFile) {
              alert(STRINGS.ERROR_IMAGE_ONLY);
              return null;
            }
          };
        }

        function insertFavicon(file) {
          const oldElement = document.querySelector(querySelector);
          oldElement.remove();
          const newElement = document.createElement("link");
          newElement.rel = "icon";
          setFileAsDataURL(file, newElement, "href");
          const faviconPreviewElement = document.getElementById(
            CURRENT_FAVICON_PREVIEW_ID
          );
          setFileAsDataURL(file, faviconPreviewElement);
          document.getElementsByTagName("head")[0].appendChild(newElement);
        }

        function onUpdateBackgorundColor(changeEvent) {
          document.body.style.backgroundColor = changeEvent.target.value;
          editingStateDirty = true;
        }

        function uniqueId(readableString) {
          return `${readableString}-${Math.random().toString().slice(2, 12)}`;
        }

        function createElement(type) {
          return document.createElement(type);
        }

        function slugify(string) {
          return string.split(" ").join("-").toLowerCase();
        }

        function getEditorContainerId(editorId) {
          return `container-${editorId}`;
        }

        function getButtonId(label, editorId) {
          return `${slugify(label)}-${editorId}`;
        }

        function isImageFile(file) {
          if (!file.type.startsWith("image/")) {
            return false;
          }
          return true;
        }

        function addAtEndOfDocument(element) {
          document
            .getElementById(END_OF_DOC_ID)
            .insertAdjacentElement("beforebegin", element);
        }

        function scrollToNewElement(element) {
          const elementTop = element.getBoundingClientRect().top;
          if (elementTop < 0) {
            const { scrollTop } = document.documentElement;
            const scrollTo = elementTop + scrollTop - 20;
            window.scrollTo(0, scrollTo < 0 ? 0 : scrollTo);
          }
        }

        function addLinkAroundSelection(selectableInput) {
          const {
            selectionStart: start,
            selectionEnd: end,
            value,
          } = selectableInput;
          if (start === end) {
            alert(STRINGS.ERROR_NO_SELECTION);
            return value;
          }
          const selection = value.substring(start, end);
          const url = window.prompt(STRINGS.PROMPT_LINK_URL);
          return `${value.slice(
            0,
            start
          )}<a href="${url}" target="_blank">${selection}</a>${value.slice(
            end,
            value.length
          )}`;
        }

        function getBodyBackgroundColor() {
          return rgb2hex(
            document.body?.style?.backgroundColor ?? "rgb(255, 255, 255)"
          );
        }

        // https://stackoverflow.com/questions/1740700/how-to-get-hex-color-value-rather-than-rgb-value
        function rgb2hex(rgb) {
          return `#${rgb
            .match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/)
            .slice(1)
            .map((n) => parseInt(n, 10).toString(16).padStart(2, "0"))
            .join("")}`;
        }

        function setFileAsDataURL(file, element, property = "src") {
          const reader = new FileReader();
          reader.onload = ((_element) => (event) => {
            _element[property] = event.target.result;
          })(element);
          reader.readAsDataURL(file);
        }
      }
    </script>
  </body>
</html>
